
Sprof was developed by MÃ¡rcio Jales (marcio.dojcosta@gmail.com), at UFRN (Universidade Federal do Rio Grande do Norte), as part of the undegraduate thesis in computer engineering.
Date: 09/12/2016.

This document describes the essentials about the sprof toolsuite. It consists of:
- "sprof" binary executable (writter in C);
- "sprof_instr.sh" shell script;
- and the "libsprof.so" shared library.

It is organized as shown below:

SECTION 1 - WHAT IS SPROF
SECTION 2 - HOW SPROF WORKS
SECTION 3 - INSTRUMENTING THE CODE
SECTION 4 - AUTOMATIC INSTRUMENTATION
SECTION 5 - CONFIGURING THE SPROF EXECUTION
SECTION 6 - EXECUTING SPROF
SECTION 7 - GENERAL INFORMATIONS

The entire suite is licensed under the GPL v3.0.

------------------------------------------------------------------------------------

SECTION 1 - WHAT IS SPROF

The main tool (the "sprof" binary executable, written in C) executes an user application (called "target") repeatedly, for the same size of problem, but different number of threads, so that it is able to calculate the speedup of the target. The user must, first of all, instrument its application using specific functions provided by the Sprof library "libsprof.so". If he/she wants it to be made automatically, there is an executable shell script called "sprof_instr.sh" that may perform such task in certain conditions.  

That said, the tool suite aims two things, basically:

First, a test plataform to create a profile about the speedup of multithread applications. This is acomplished by the binary executable called "sprof".
Second, to instrument the source-code of these applications automatically. This is acomplished by the shell script called "sprof_instr.sh".

The tool was tested for OpenMP and Pthreads application.

------------------------------------------------------------------------------------

SECTION 2 - HOW SPROF WORKS

The user must instrument its target application that he/she wishes to be measured. In order to do so, he/she must use the library provided, named "libsprof.so".

Next, the user executes "sprof", passing, as arguments, the binary executable of the target application and all its necessary arguments. To configure how "sprof" will perform the tests, he/she must configure the file "sprof_exec.conf". There, it will be informed how many tests will be made and the number of threads that will be used.

------------------------------------------------------------------------------------

SECTION 3 - INSTRUMENTING THE CODE

In order to execute correctly, the functions provides by sprof library must be placed accordingly by the user (or using "sprof_instr.sh". This will be explained on the next section). 

There are 5 functions available for this purpose:

	1 - sprof_start: does not return and does not receive any arguments. It marks the beginning of the parallel area to be measured.

	2 - sprof_stop: does not return and does not receive any arguments. It marks the end of the parallel area to be measured.

	When using Pthreads, it is possibly to determine the behavior of the threads very especificaly. Threads can be created and terminated whenever the programmer wants, in contrast to OpenMP, on that threads are created and terminated in blocks. Beacuse of that, sprof library provides also both functions below.

	3 - sprof_pthstart: does not return, but receives one argument of "pthread_t" type, whose value consists of the thread ID that the information gathering is going to start. This function should be used instead of "sprof_start" when there is a more fine-grained measurement involving pthreads, as explained previously.

	4 - sprof_pthstop: does not return, but receives one argument of "pthread_t" type, whose value consists of the thread ID that that the information gathering is going to finish. This function should be used instead of "sprof_stop" when there is a more fine-grained measurement involving pthreads, as explained previously as well.

	5 - sprof_thrnum: sprof may use the target application's arguments to configure how many threads it will be executed. If this is not possible, the user must place the "sprof_thrnum" function in the code. It does not return and receives one argument, a pointer to integer (*int), that must be the variable in the program that holds the number of threads to use. Thus, the use of "sprof_thrnum" function may be optional.

	It is important to highlight that all the intrumentation works only OUTSIDE the parallel areas. Sprof does not handle race conditions and other problems that arises inside parallel implementations.

------------------------------------------------------------------------------------

SECTION 4 - AUTOMATIC INSTRUMENTATION

Sometimes, looking into a code and placing instrumentation can be tricky. With that in mind, the shell script "sprof_instr.sh" was created as a first trial to automatically instrument code using the sprof library. Currently, it inserts only "sprof_start" and "sprof_stop" functions in OpenMP directives that start with "pragma omp parallel".

To use this functionality, the command line consists of:

	<path_to_script>/sprof_instr.sh <openmp|clean>.
	
That is, there are two options to invoke the script. 

The "openmp" option is the actual instrumentation of the code, it inserts the "include" directive with the full path to "sprofops.h", the "sprof_start" function right before the "pragma omp parallel" and "sprof_stop" right after the key "}" that represents the end of the parallel region.

The "clean" options provides the withdraw of the instrumentation marks, so that the user does not have to do this manually every time he/she whishes compile his/her code without Sprof library.

------------------------------------------------------------------------------------

SECTION 5 - CONFIGURING THE SPROF EXECUTION

The configuration of the profiler's execution is controlled by the "sprof_exec.conf" configuration file. There are five variables that may be used in two distinct ways to configure Sprof. For both, the use of "number_of_tests" is mandatory. It determines how many times the tests will run on the target application.	

Thus, the first possibility of configuration uses the "list_threads_values" variable. It consists of a list with the number of threads that should be uses on each test. The values must be comma-separated, between keys and without spaces. For example, the declaration "list_threads_values={2,5,8,17}" will execute tests for 2, 5, 8 and 17 threads, respectively. Note that the test with 1 thread will always be executed, so it does not have to be assigned in the list os values.

The second possibility uses a set of three variables: "max_number_threads", "type_of_step" and "value_of_step". The first one dictates the upper limit of the number of threads that will be executed on the test. The second one may assume only two values: "power" and "constant". "power" means that the number of threads the target will run will be incremented in a geometric progression fashion, while the "constant" option will increment the number in a arithmetic progression fashion. The last variable gives the value to increment the number of thread on each step of the test. Consider, then, three examples below:

	1 - The set "max_number_threads=16", "type_of_step=power" and "value_of_step=2" will configure the target application to execute with 1, 2, 4, 8 and 16 threads;
	2 - The set "max_number_threads=32", "type_of_step=power" and "value_of_step=3" will configure the target application to execute with 1, 3, 9 and 27 threads;
	3 - The set "max_number_threads=33", "type_of_step=constant" and "value_of_step=4" will configure the target application to execute with 1, 5, 9, 13, 17, 21, 25, 29 and 33 threads.
	
------------------------------------------------------------------------------------

SECTION 6 - EXECUTING SPROF

The profiler is invoked by command line, as shown below:

	<path_to_profiler>/sprof [OPTIONS] <target> <target's arguments>
	
The only option available to use with sprof is the "-t" option. If passed to, this option means that the target application has one of its arguments consisting of the number of threds that it will run. Thus, consider the next examples:

	1 - An application named "app" has three arguments, where the second represents the number of threads that "app" will fork to execute. The option "-t" may be used then: "sprof -t 2 app arg1 arg2 arg3";
	2 - An application named "foo" has four arguments, where the fourth represents the number of threads that "foo" will fork to execute. The option "-t" may be used then: "sprof -t 4 foo arg1 arg2 arg3 arg4";
	2 - An application named "bar" has six arguments, where none of them represents the number of threads. The option "-t" may NOT be used then: "sprof bar arg1 arg2 arg3 arg4 arg5 arg6".
	
	Notice that if the user inserts the function "sprof_thrnum" (refer to section 3) in his/her application, "-t" isn't necessary even if the target passes the number of threads in its arguments.




	





	

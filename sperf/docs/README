
Sperf was developed by MÃ¡rcio Jales (marcio.dojcosta@gmail.com), at UFRN (Universidade Federal do Rio Grande do Norte), as part of the undegraduate thesis in computer engineering.
Date: 09/12/2016.

This document describes the essentials about the sperf toolsuite. It consists of:
- "sperf" binary executable;
- "sperf_instr.sh" shell script ;
- and the "libsperf.so" shared library.

It is organised as shown below:

SECTION 1 - WHAT IS SPERF
SECTION 2 - HOW SPERF WORKS
SECTION 3 - INSTRUMENTING THE CODE
SECTION 4 - AUTOMATIC INSTRUMENTATION
SECTION 5 - CONFIGURING THE SPERF EXECUTION
SECTION 6 - EXECUTING SPERF
SECTION 7 - GENERAL INFORMATIONS

The entire suite is licensed under the GPL v3.0.

------------------------------------------------------------------------------------

SECTION 1 - WHAT IS SPERF

The toolsuite aims two things, basically:

First, a test plataform to create a profile about the speedup of multithread applications. This is acomplished by the binary executable called "sperf".
Second, to instrument the source-code of these applications automatically. This is acomplished by the shell script called "sperf_instr.sh".

In other words, Sperf executes an user application repeatedly, for the same size of problem, but different number of threads, so that it is able to calculate the speedup of that application.

The tool was tested for OpenMP and Pthreads application.

------------------------------------------------------------------------------------

SECTION 2 - HOW SPERF WORKS

The user must instrument its target application that he/she wishes to be measured. In order to do so, he/she must use the library provided, named "libsperf.so".

Next, the user executes "sperf", passing, as arguments, the binary executable of the target application and all its necessary arguments. To configure how "sperf" will perform the tests, he/she must configure the file "sperf_exec.conf". There, it will be informed how many tests will be made and the number of threads that will be used.

------------------------------------------------------------------------------------

SECTION 3 - INSTRUMENTING THE CODE

In order to execute correctly, the functions provides by sperf library must be placed accordingly by the user (or using "sperf_instr.sh". This will be explained on the next section). 

There are 5 functions available for this purpose:

	1 - sperf_start: does not return and does not receive any arguments. It marks the beginning of the parallel area to be measured.

	2 - sperf_stop: does not return and does not receive any arguments. It marks the end of the parallel area to be measured.

	When using Pthreads, it is possibly to determine the behavior of the threads very especificaly. Threads can be created and terminated whenever the programmer wants, in contrast to OpenMP, on that threads are created and terminated in blocks. Beacuse of that, sperf library provides also both functions below.

	3 - sperf_pthstart: does not return, but receives one argument of "pthread_t" type, whose value consists of the thread ID that the information gathering is going to start. This function should be used instead of "sperf_start" when there is a more fine-grained measurement involving pthreads, as explained previously.

	4 - sperf_pthstop: does not return, but receives one argument of "pthread_t" type, whose value consists of the thread ID that that the information gathering is going to finish. This function should be used instead of "sperf_stop" when there is a more fine-grained measurement involving pthreads, as explained previously as well.

	5 - sperf_thrnum: sperf may use the target application's arguments to configure how many threads it will be executed. If this is not possible, the user must place the "sperf_thrnum" function in the code. It does not return and receives one argument, a pointer to integer (*int), that must be the variable in the program that holds the number of threads to use. Thus, the use of "sperf_thrnum" function may be optional.

	It is important to highlight that all the intrumentation works only OUTSIDE the parallel areas. Sperf does not handle race conditions and other problems that arises inside parallel implementations.

------------------------------------------------------------------------------------

SECTION 4 - AUTOMATIC INSTRUMENTATION

Sometimes, looking into a code and placing instrumentation can be tricky. With that in mind, the shell script "sperf_instr.sh" was created as a first trial to automatically instrument code using the sperf library. Currently, it inserts only "sperf_start" and "sperf_stop" functions in OpenMP directives that start with "pragma omp parallel".

To use 




	
